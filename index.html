<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>54655F616D6F5F4D6167616C69</title>
    <link rel="preload" href="snoopy.png" as="image">
    <link rel="preload" href="luffy.png" as="image">
    <link rel="preload" href="deku.png" as="image">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            font-family: 'Segoe UI', sans-serif;
            background-color: #6bbd67;
            background-image: 
                radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.3) 100%),
                radial-gradient(circle at center, rgba(175, 220, 160, 0.4) 0%, rgba(107, 191, 89, 0.6) 80%, rgba(70, 140, 60, 0.8) 100%),
                repeating-linear-gradient(
                    0deg,
                    rgba(0,0,0,0.1) 0px,
                    rgba(0,0,0,0.1) 1px,
                    transparent 1px,
                    transparent 3px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(0,0,0,0.05) 0px,
                    rgba(0,0,0,0.05) 1px,
                    transparent 1px,
                    transparent 3px
                ),
                linear-gradient(
                    160deg, 
                    #8BC34A 0%,
                    #689F38 40%,
                    #33691E 80%,
                    #214715 100%
                );
            background-blend-mode: multiply, overlay, soft-light, soft-light, normal;
            background-size: cover, cover, 100% 100%, 100% 100%, cover;
        }

        .garden {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .sparkle {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            pointer-events: none;
            animation: sparkle-burst 0.5s forwards;
            box-shadow: 0 0 5px #ffea00, 0 0 10px #ffea00, 0 0 15px #ffea00;
            z-index: 2;
        }

        .dust-particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            pointer-events: none;
            animation: float-particle var(--duration) linear infinite;
            filter: blur(1px);
            opacity: 0;
            animation-delay: var(--delay);
            z-index: 0;
        }

        .petal-particle {
            position: absolute;
            pointer-events: none;
            animation: float-particle var(--duration) linear infinite;
            opacity: 0;
            animation-delay: var(--delay);
            z-index: 0;
            filter: blur(1px);
            width: var(--size);
            height: var(--size);
            background-color: var(--color);
            border-radius: 40% 60% 40% 60% / 50% 50% 50% 50%;
        }

        .character {
            position: absolute;
            width: 80px;
            height: auto;
            opacity: 0;
            cursor: pointer;
            filter: drop-shadow(0 0 8px rgba(255, 255, 204, 0.8)); 
            z-index: 5;
        }
        
        .character.disappear {
            animation: character-disappear 0.6s ease-in forwards;
            pointer-events: none;
        }
        
        .vortex-effect {
            position: absolute;
            border: 2px solid rgba(173, 216, 230, 0.7);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(173, 216, 230, 0.9), 0 0 25px rgba(173, 216, 230, 0.6);
            pointer-events: none;
            opacity: 0;
            transform: scale(0);
            animation: vortex-pulse 1s forwards infinite;
            z-index: 3;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 204, 0.95);
            border: 2px solid #d4af37;
            border-radius: 12px;
            padding: 15px;
            max-width: 90%;
            text-align: center;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
            z-index: 10;
            animation: message-fade-in 1s ease-out forwards;
        }

        .message-box h1 {
            font-family: 'Papyrus', fantasy;
            color: #d4af37;
            margin-bottom: 8px;
            font-size: 1.2em;
        }

        .message-box p {
            font-size: 0.9em;
            color: #4b3b2f;
        }
        
        #fecha-fija {
            margin-top: 10px;
            font-size: 0.8em;
            color: #888;
        }

        .character-message {
            position: absolute;
            background: rgba(255, 255, 204, 0.9);
            border-radius: 10px;
            padding: 10px 15px;
            font-size: 0.9em;
            color: #4b3b2f;
            white-space: nowrap;
            opacity: 0;
            animation: character-message-show 1s ease-out forwards;
            pointer-events: none;
            z-index: 6;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .character-finale-sparkle {
            position: absolute;
            background: radial-gradient(circle, rgba(255, 234, 0, 1) 0%, rgba(255, 234, 0, 0.5) 40%, rgba(255, 234, 0, 0) 100%);
            border-radius: 50%;
            pointer-events: none;
            animation: character-finale-sparkle-anim 1.5s ease-out forwards;
            z-index: 4;
            transform: scale(0);
        }
        
        @keyframes vortex-pulse {
            0% { transform: scale(0.5); opacity: 0.8; }
            50% { transform: scale(1); opacity: 0.4; }
            100% { transform: scale(0.5); opacity: 0.8; }
        }

        @keyframes sparkle-burst {
            from {
                transform: scale(0);
                opacity: 1;
            }
            to {
                transform: scale(2);
                opacity: 0;
            }
        }

        @keyframes float-particle {
            0% {
                transform: translate(0, 0) scale(var(--scale));
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translate(var(--endX), var(--endY)) scale(var(--scale));
                opacity: 0;
            }
        }

        @keyframes float-character {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(2deg); }
            100% { transform: translateY(0px) rotate(0deg); }
        }
        
        @keyframes character-appear {
            from { opacity: 0; transform: scale(0.5) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0px); }
        }

        @keyframes character-disappear {
            0% { opacity: 1; transform: scale(1) rotate(0deg); }
            100% { opacity: 0; transform: scale(0.2) rotate(30deg); }
        }

        @keyframes character-color-change {
            from { filter: hue-rotate(0deg) drop-shadow(0 0 8px rgba(255, 255, 204, 0.8)); }
            to { filter: hue-rotate(360deg) drop-shadow(0 0 8px rgba(255, 255, 204, 0.8)); }
        }

        @keyframes message-fade-in {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        @keyframes character-message-show {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        @keyframes character-message-fade {
            to { opacity: 0; }
        }
        
        @keyframes character-finale-sparkle-anim {
            from { transform: scale(0); opacity: 1; }
            to { transform: scale(1); opacity: 0; }
        }

        @keyframes vortex-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }


    </style>
</head>
<body>
    <div class="garden" id="garden">
        <canvas id="flower-canvas"></canvas>
    </div>

    <div class="message-box" id="message-box">
        <h1>üåª Jard√≠n M√°gicoüêæ</h1>
        <img src="snoopy2.png" alt="Snoopy dando la bienvenida" style="width: 100px; height: auto; margin-bottom: 10px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">

        <p>
        <strong>Maggiieeeeeeeeeeeeee!!!!!!!!!!</strong>
        </p>
        <p>
        Te regalo un jardin de flores :)
        </p>
        <div id="fecha-fija">21/09/2025</div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            // --- Setup ---
            const garden = document.getElementById('garden');
            const messageBox = document.getElementById('message-box');
            const canvas = document.getElementById('flower-canvas');
            const ctx = canvas.getContext('2d');

            let windEffect = 0;
            let targetWindEffect = 0;
            let isDrawing = false;
            let isVortexActive = false;
            let vortexEffectElement = null;
            let themedFlowerType = null;
            let lastFlowerTime = 0;
            const flowerGenerationDelay = 100;
            const flowerMaxAge = 45000;

            // --- Object Pools for Performance ---
            let flowers = [];
            let dustParticles = [];
            let petalParticles = [];

            const characters = [
                {
                    name: 'snoopy',
                    type: 'main',
                    flowerType: 3,
                    src: 'snoopy.png',
                    messages: [
                        "¬°Para ti, con cari√±o! üåª", "Las flores traen felicidad. üòä", "Te quiero mucho!!!!!!!. ‚ú®",
                        "¬°Que tu d√≠a florezca como estas flores! üíõ", "¬°Gracias por estar :) ! üíõ", "¬°Eres incre√≠ble! üåü",
                        "¬°Sigue brillando! üåû", "¬°Eres una flor en este jard√≠n! üå∏", "¬°Tu sonrisa ilumina el d√≠a! üòÑ",
                        "¬°Eres especial! üåü", "¬°Nunca dejes de so√±ar! üåà", "¬°Sigue haciendote mas fuerte! üå±",
                        "¬°Eres maravillosa! üåü", "¬°Eres un rayo de sol! ‚òÄÔ∏è", "¬°Eres una inspiraci√≥n! üåü",
                        "¬°Gracias por escucharme! üíñ", "¬°Eres mi persona favorita! üíï", "¬°Disfruto mucho tu compa√±√≠a! üòä",
                    ]
                },
                {
                    name: 'luffy',
                    type: 'guest',
                    flowerType: 4,
                    src: 'luffy.png',
                    messages: [
                        "¬°Voy a ser el Rey de los Piratas!", "¬°La carne es lo mejor!", "¬°Esto es muy divertido!",
                        "¬°Tengo a los mejores nakamas!", "¬°Gomu Gomu no...!",
                    ]
                },
                {
                    name: 'deku',
                    type: 'guest',
                    flowerType: 5,
                    src: 'deku.png',
                    messages: [
                        "¬°Plus Ultra!", "¬°Tengo que esforzarme m√°s!", "¬°Un h√©roe siempre encuentra la manera!",
                        "¬°One For All! ¬°100%!", "¬°Puedo ser un h√©roe!",
                    ]
                }
            ];
            let activeCharacters = {};

            // --- Canvas & Window Setup ---
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            setTimeout(() => {
                if (messageBox) messageBox.style.display = 'none';
            }, 10000);

            // --- Particle Creation (Canvas) ---
            function createDustParticle() {
                const randomFactor = Math.random();
                dustParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 1 + randomFactor * 3,
                    opacity: 1,
                    life: 1, // 1 = full life, 0 = dead
                    duration: 8 + (1 - randomFactor) * 12, // 8s to 20s
                    speedX: (Math.random() - 0.5) * 20,
                    speedY: (Math.random() - 0.5) * 20,
                });
            }

            function createPetalParticle() {
                const randomFactor = Math.random();
                const hue = 330 + Math.random() * 60;
                petalParticles.push({
                    x: Math.random() * canvas.width,
                    y: -20,
                    size: 5 + randomFactor * 8,
                    opacity: 1,
                    life: 1,
                    duration: 8 + (1 - randomFactor) * 12,
                    speedX: (Math.random() - 0.5) * 40,
                    speedY: 20 + Math.random() * 20,
                    color: `hsla(${hue}, ${70 + Math.random() * 30}%, ${65 + Math.random() * 15}%, 0.6)`,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 2,
                });
            }

            // --- Flower Creation ---
            function createFlower(x, y, themeType = null) {
                const randomScale = 0.7 + Math.random() * 0.6;
                const isSpecialColor = Math.random() < 0.15;
                let hue, saturation, lightness;

                if (!isSpecialColor) {
                    hue = 40 + Math.random() * 20;
                    saturation = 80 + Math.random() * 20;
                    lightness = 50 + Math.random() * 20;
                } else {
                    const specialColors = [
                        { hue: 350, saturation: 80, lightness: 65 }, { hue: 20, saturation: 90, lightness: 60 },
                        { hue: 250, saturation: 70, lightness: 70 },
                    ];
                    const selectedColor = specialColors[Math.floor(Math.random() * specialColors.length)];
                    hue = selectedColor.hue; saturation = selectedColor.saturation; lightness = selectedColor.lightness;
                }

                let flowerType = (themeType !== null && Math.random() < 0.3) ? themeType : Math.floor(Math.random() * 3);

                flowers.push({
                    x, y, scale: randomScale, currentRotation: Math.random() * 360,
                    color: `hsl(${hue}, ${saturation}%, ${lightness}%)`,
                    creationTime: Date.now(), isBeingAbsorbed: false, isDisappearing: false, flowerType
                });
            }
            
            function removeFlowersByType(type) {
                flowers.forEach(flower => {
                    if (flower.flowerType === type) flower.isDisappearing = true;
                });
            }

            // --- Drawing Functions ---
            function drawFlower(flower) {
                ctx.save();
                ctx.translate(flower.x, flower.y);
                ctx.rotate(windEffect + flower.currentRotation * Math.PI / 180);
                ctx.scale(flower.scale, flower.scale);

                if (flower.flowerType >= 3) {
                    ctx.shadowColor = 'rgba(255, 223, 0, 0.75)';
                    ctx.shadowBlur = Math.sin(Date.now() / 400) * 5 + 10;
                }

                // Stem and leaves
                ctx.strokeStyle = '#33691E';
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 40); ctx.stroke();
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath(); ctx.ellipse(5, 20, 12, 6, -Math.PI / 5, 0, 2 * Math.PI); ctx.fill();
                ctx.beginPath(); ctx.ellipse(-5, 25, 12, 6, Math.PI / 5, 0, 2 * Math.PI); ctx.fill();
                
                const hslMatch = flower.color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                let lighterColor = flower.color, darkerColor = flower.color;
                if (hslMatch) {
                    const [_, h, s, l] = hslMatch;
                    lighterColor = `hsl(${h}, ${s}%, ${Math.min(100, parseInt(l) + 20)}%)`;
                    darkerColor = `hsl(${h}, ${s}%, ${Math.max(0, parseInt(l) - 20)}%)`;
                }
                const gradient = ctx.createRadialGradient(0, 0, 1, 0, 0, 25);
                gradient.addColorStop(0, lighterColor);
                gradient.addColorStop(1, flower.color);
                ctx.fillStyle = gradient;
                ctx.strokeStyle = darkerColor;
                ctx.lineWidth = 1;

                // Petals based on type
                // (The drawing logic for each flower type remains the same)
                switch (flower.flowerType) {
                    case 0: // Original flower
                    default:
                        const petalCount = 8;
                        for (let i = 0; i < petalCount; i++) {
                            const angle = (i / petalCount) * 2 * Math.PI;
                            ctx.save(); ctx.rotate(angle);
                            ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(15, 15, 0, 30); ctx.quadraticCurveTo(-15, 15, 0, 0);
                            ctx.fill(); ctx.stroke();
                            ctx.restore();
                        }
                        break;
                    case 1: // Daisy-like flower
                        const daisyPetals = 12;
                        for (let i = 0; i < daisyPetals; i++) {
                            const angle = (i / daisyPetals) * 2 * Math.PI;
                            ctx.save(); ctx.rotate(angle);
                            ctx.beginPath(); ctx.ellipse(0, 18, 4, 15, 0, 0, 2 * Math.PI);
                            ctx.fill(); ctx.stroke();
                            ctx.restore();
                        }
                        break;
                    case 2: // Tulip-like flower
                        const tulipPetals = 3;
                        for (let i = 0; i < tulipPetals; i++) {
                            const angle = (i / tulipPetals) * 2 * Math.PI;
                            ctx.save(); ctx.rotate(angle);
                            ctx.beginPath(); ctx.moveTo(0, -10); ctx.quadraticCurveTo(25, 10, 20, 30); ctx.lineTo(-20, 30); ctx.quadraticCurveTo(-25, 10, 0, -10); ctx.closePath();
                            ctx.fill(); ctx.stroke();
                            ctx.restore();
                        }
                        break;
                    case 3: // Snoopy Flower
                        ctx.fillStyle = 'white'; ctx.strokeStyle = '#E0E0E0';
                        const snoopyPetals = 12;
                        for (let i = 0; i < snoopyPetals; i++) {
                            const angle = (i / snoopyPetals) * 2 * Math.PI;
                            ctx.save(); ctx.rotate(angle);
                            ctx.beginPath(); ctx.ellipse(0, 18, 6, 15, 0, 0, 2 * Math.PI);
                            ctx.fill(); ctx.stroke();
                            ctx.restore();
                        }
                        ctx.beginPath(); ctx.arc(0, 0, 10, 0, 2 * Math.PI); ctx.fillStyle = 'black'; ctx.fill();
                        break;
                    case 4: // Luffy Flower
                        ctx.fillStyle = '#FFD700'; ctx.strokeStyle = '#DAA520'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.ellipse(0, 5, 35, 15, 0, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#FBC02D';
                        ctx.beginPath(); ctx.moveTo(-20, -5); ctx.quadraticCurveTo(0, -30, 20, -5); ctx.closePath(); ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#FF1744'; ctx.strokeStyle = '#C4001D'; ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.rect(-22, -8, 44, 10); ctx.fill(); ctx.stroke();
                        break;
                    case 5: // Deku Flower
                        ctx.fillStyle = '#008000'; ctx.strokeStyle = '#006400';
                        const dekuPetals = 8;
                        for (let i = 0; i < dekuPetals; i++) {
                            const angle = (i / dekuPetals) * 2 * Math.PI + (Math.PI / dekuPetals);
                            ctx.save(); ctx.rotate(angle);
                            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(10, 30); ctx.lineTo(-10, 30); ctx.closePath();
                            ctx.fill(); ctx.stroke();
                            ctx.restore();
                        }
                        ctx.beginPath(); ctx.arc(0, 0, 8, 0, 2 * Math.PI); ctx.fillStyle = '#2F4F4F'; ctx.fill();
                        break;
                }

                if (flower.flowerType < 3) {
                    const pulse = Math.sin((Date.now() - flower.creationTime) / 400) * 5 + 40;
                    ctx.beginPath(); ctx.arc(0, 0, 12, 0, 2 * Math.PI);
                    ctx.fillStyle = `hsla(24, 55%, ${pulse}%, 0.9)`;
                    ctx.fill();
                    ctx.strokeStyle = "rgba(92, 51, 23, 0.8)"; ctx.lineWidth = 1.5; ctx.stroke();
                }
                ctx.restore();
            }

            function drawParticles(deltaTime) {
                // Dust
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                for (let i = dustParticles.length - 1; i >= 0; i--) {
                    const p = dustParticles[i];
                    p.life -= deltaTime / p.duration;
                    if (p.life <= 0) {
                        dustParticles.splice(i, 1);
                        continue;
                    }
                    p.x += p.speedX * deltaTime;
                    p.y += p.speedY * deltaTime;
                    p.opacity = p.life > 0.5 ? (1 - p.life) * 2 : p.life * 2;
                    ctx.globalAlpha = p.opacity;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                    ctx.fill();
                }

                // Petals
                for (let i = petalParticles.length - 1; i >= 0; i--) {
                    const p = petalParticles[i];
                    p.life -= deltaTime / p.duration;
                    if (p.life <= 0 || p.y > canvas.height + p.size) {
                        petalParticles.splice(i, 1);
                        continue;
                    }
                    p.x += (p.speedX + windEffect * 100) * deltaTime;
                    p.y += p.speedY * deltaTime;
                    p.rotation += p.rotationSpeed * deltaTime;
                    p.opacity = p.life > 0.5 ? (1 - p.life) * 2 : p.life * 2;
                    
                    ctx.globalAlpha = p.opacity;
                    ctx.fillStyle = p.color;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, p.size, p.size / 2, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }

            // --- Main Animation Loop ---
            let lastTime = 0;
            function animate(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000 || 0;
                lastTime = currentTime;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                windEffect += (targetWindEffect - windEffect) * 0.05;

                // --- Update and Draw Particles ---
                drawParticles(deltaTime);

                // --- Update and Draw Flowers ---
                const activeCharacterElements = Object.values(activeCharacters).filter(el => el);
                const vortexPos = isVortexActive && vortexEffectElement ? {
                    x: parseFloat(vortexEffectElement.style.left) + parseFloat(vortexEffectElement.style.width) / 2,
                    y: parseFloat(vortexEffectElement.style.top) + parseFloat(vortexEffectElement.style.height) / 2,
                    radius: 150
                } : null;

                for (let i = flowers.length - 1; i >= 0; i--) {
                    const flower = flowers[i];
                    
                    // 1. Update state (aging, disappearing)
                    if (!flower.isDisappearing && (currentTime - flower.creationTime > flowerMaxAge)) {
                        flower.isDisappearing = true;
                    }
                    if (flower.isDisappearing) {
                        flower.scale *= 0.95;
                        flower.currentRotation += 10;
                    }

                    // 2. Check for removal
                    if (flower.scale < 0.05 || flower.x < -100 || flower.x > canvas.width + 100 || flower.y < -100 || flower.y > canvas.height + 100) {
                        flowers.splice(i, 1);
                        continue;
                    }

                    // 3. Handle interactions (absorption, vortex)
                    flower.isBeingAbsorbed = false;
                    let absorbed = false;

                    // Character absorption
                    for (const charElement of activeCharacterElements) {
                        const rect = charElement.getBoundingClientRect();
                        const charX = rect.left + rect.width / 2;
                        const charY = rect.top + rect.height / 2;
                        const dx = flower.x - charX;
                        const dy = flower.y - charY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const absorptionRadius = window.innerWidth < 768 ? 120 : 250;

                        if (distance < absorptionRadius) {
                            flower.isBeingAbsorbed = true;
                            flower.x -= dx * 0.05; flower.y -= dy * 0.05;
                            flower.scale *= 0.98; flower.currentRotation += 5;
                            if (flower.scale < 0.1 || distance < 10) {
                                createSparkle(flower.x, flower.y, 5);
                                flowers.splice(i, 1);
                                absorbed = true;
                            }
                            break;
                        }
                    }
                    if (absorbed) continue;

                    // Vortex absorption
                    if (vortexPos) {
                        const dx = flower.x - vortexPos.x;
                        const dy = flower.y - vortexPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < vortexPos.radius) {
                            flower.isBeingAbsorbed = true;
                            flower.x -= dx * 0.08; flower.y -= dy * 0.08;
                            flower.scale *= 0.98; flower.currentRotation += 10;
                            if (flower.scale < 0.1 || distance < 10) {
                                createSparkle(flower.x, flower.y, 5);
                                flowers.splice(i, 1);
                                continue;
                            }
                        }
                    }

                    // 4. Update rotation and draw
                    if (!flower.isBeingAbsorbed) {
                        flower.currentRotation += 0.1;
                    }
                    drawFlower(flower);
                }
                
                // --- Generate new flowers ---
                if (Date.now() - lastFlowerTime > 200) {
                    createFlower(Math.random() * canvas.width, Math.random() * canvas.height, themedFlowerType);
                    lastFlowerTime = Date.now();
                }

                requestAnimationFrame(animate);
            }
            
            // --- DOM Element Creation (Sparkles, Messages, etc.) ---
            function createSparkle(x, y, count = 5) {
                for (let i = 0; i < count; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.classList.add('sparkle');
                    const size = 5 + Math.random() * 10;
                    sparkle.style.cssText = `
                        width: ${size}px; height: ${size}px;
                        left: ${x + (Math.random() - 0.5) * 20}px;
                        top: ${y + (Math.random() - 0.5) * 20}px;
                    `;
                    document.body.appendChild(sparkle);
                    setTimeout(() => sparkle.remove(), 500);
                }
            }

            // --- Event Handlers ---
            function handleInteraction(e, type) {
                const clientX = e.clientX ?? e.touches?.[0]?.clientX;
                const clientY = e.clientY ?? e.touches?.[0]?.clientY;
                if (clientX === undefined) return;

                if (e.shiftKey || (type === 'vortex' && isVortexActive)) {
                    if (!vortexEffectElement) {
                        vortexEffectElement = document.createElement('div');
                        vortexEffectElement.classList.add('vortex-effect');
                        garden.appendChild(vortexEffectElement);
                    }
                    const vortexSize = 100;
                    vortexEffectElement.style.cssText = `
                        width: ${vortexSize}px; height: ${vortexSize}px;
                        left: ${clientX - vortexSize / 2}px; top: ${clientY - vortexSize / 2}px;
                        opacity: 1;
                    `;
                    isVortexActive = true;
                } else {
                    if (vortexEffectElement) {
                        vortexEffectElement.style.opacity = 0;
                        vortexEffectElement.remove();
                        vortexEffectElement = null;
                    }
                    if (Date.now() - lastFlowerTime > flowerGenerationDelay) {
                        createFlower(clientX, clientY, themedFlowerType);
                        lastFlowerTime = Date.now();
                    }
                }
            }

            function setupEventListeners() {
                window.addEventListener('mousemove', (e) => {
                    targetWindEffect = (e.clientX / window.innerWidth - 0.5) * 0.4;
                });

                canvas.addEventListener('mousedown', (e) => { isDrawing = true; handleInteraction(e, 'draw'); });
                canvas.addEventListener('mousemove', (e) => { if (isDrawing) handleInteraction(e, e.shiftKey ? 'vortex' : 'draw'); });
                const stopDrawing = () => {
                    isDrawing = false; isVortexActive = false;
                    if (vortexEffectElement) {
                        vortexEffectElement.style.opacity = 0;
                        vortexEffectElement.remove();
                        vortexEffectElement = null;
                    }
                };
                canvas.addEventListener('mouseup', stopDrawing);
                canvas.addEventListener('mouseleave', stopDrawing);

                canvas.addEventListener('touchstart', (e) => { e.preventDefault(); isDrawing = true; handleInteraction(e, 'draw'); }, { passive: false });
                canvas.addEventListener('touchmove', (e) => { e.preventDefault(); if (isDrawing) handleInteraction(e, 'draw'); }, { passive: false });
                canvas.addEventListener('touchend', stopDrawing);

                canvas.addEventListener('click', (e) => {
                    for (let i = flowers.length - 1; i >= 0; i--) {
                        const flower = flowers[i];
                        if (Math.sqrt((e.clientX - flower.x)**2 + (e.clientY - flower.y)**2) < 30 * flower.scale) {
                            createSparkle(e.clientX, e.clientY, 20);
                            flowers.splice(i, 1);
                            break;
                        }
                    }
                });
            }

            // --- Character Logic ---
            // Functions createCharacterMessage, createCharacterFinaleSparkle, showCharacter, characterCycle remain largely the same
            // as they manage DOM elements which is acceptable for a few items.
            function createCharacterMessage(character, x, y) {
                const message = document.createElement('div');
                message.classList.add('character-message');
                message.textContent = character.messages[Math.floor(Math.random() * character.messages.length)];
                
                document.body.appendChild(message); // Append to get size
                const messageWidth = message.offsetWidth;
                
                let messageX = x;
                let messageY = y - 120;

                if (messageX + messageWidth > window.innerWidth - 20) messageX = window.innerWidth - messageWidth - 20;
                if (messageX < 20) messageX = 20;
                if (messageY < 20) messageY = y + 20;

                message.style.left = `${messageX}px`;
                message.style.top = `${messageY}px`;
                
                garden.appendChild(message);
                setTimeout(() => message.remove(), 7000);
            }

            function createCharacterFinaleSparkle(x, y) {
                const finaleSparkle = document.createElement('div');
                finaleSparkle.classList.add('character-finale-sparkle');
                const size = 100 + Math.random() * 50;
                finaleSparkle.style.cssText = `
                    width: ${size}px; height: ${size}px;
                    left: ${x - size / 2}px; top: ${y - size / 2}px;
                `;
                garden.appendChild(finaleSparkle);
                setTimeout(() => finaleSparkle.remove(), 1500);
            }

            function showCharacter(characterInfo) {
                if (activeCharacters[characterInfo.name] && garden.contains(activeCharacters[characterInfo.name])) return;
                
                themedFlowerType = characterInfo.flowerType;
                const characterElement = document.createElement('img');
                characterElement.src = characterInfo.src;
                characterElement.classList.add('character');

                let animation = `float-character ${5 + Math.random() * 5}s ease-in-out infinite alternate, character-appear 0.8s ease-out forwards`;
                if (characterInfo.name === 'snoopy') animation += ', character-color-change 20s linear infinite';
                characterElement.style.animation = animation;

                if (characterInfo.type === 'guest') {
                    characterElement.style.width = '120px';
                    characterElement.style.filter = 'drop-shadow(0 0 15px rgba(255, 255, 255, 1))';
                }

                let x, y;
                const maxAttempts = 30;
                const newCharWidth = (characterInfo.type === 'guest') ? 120 : 80;
                const newCharHeight = newCharWidth * 1.2;
                const padding = 25;

                for (let i = 0; i < maxAttempts; i++) {
                    x = Math.random() * (window.innerWidth - newCharWidth);
                    y = Math.random() * (window.innerHeight - newCharHeight);
                    let overlaps = Object.values(activeCharacters).some(existingElement => {
                        if (!existingElement || !garden.contains(existingElement)) return false;
                        const rect = existingElement.getBoundingClientRect();
                        const newRect = { left: x - padding, top: y - padding, right: x + newCharWidth + padding, bottom: y + newCharHeight + padding };
                        return newRect.left < rect.right && newRect.right > rect.left && newRect.top < rect.bottom && newRect.bottom > rect.top;
                    });
                    if (!overlaps) break;
                }

                characterElement.style.left = `${x}px`;
                characterElement.style.top = `${y}px`;
                garden.appendChild(characterElement);
                activeCharacters[characterInfo.name] = characterElement;

                const disappear = () => {
                    characterElement.classList.add('disappear');
                    const rect = characterElement.getBoundingClientRect();
                    const charX = rect.left + rect.width / 2;
                    const charY = rect.top + rect.height / 2;
                    createCharacterMessage(characterInfo, charX, charY);
                    createCharacterFinaleSparkle(charX, charY);
                    setTimeout(() => {
                        characterElement.remove();
                        activeCharacters[characterInfo.name] = null;
                        if (themedFlowerType === characterInfo.flowerType) themedFlowerType = null;
                        removeFlowersByType(characterInfo.flowerType);
                    }, 600);
                };

                const autoDisappearTimeout = setTimeout(disappear, 6000);
                const handleInteraction = (e) => {
                    if (e.type === 'touchend') e.preventDefault();
                    clearTimeout(autoDisappearTimeout);
                    disappear();
                    characterElement.removeEventListener('click', handleInteraction);
                    characterElement.removeEventListener('touchend', handleInteraction);
                };
                characterElement.addEventListener('click', handleInteraction);
                characterElement.addEventListener('touchend', handleInteraction);
            }

            function characterCycle() {
                const snoopyInfo = characters.find(c => c.name === 'snoopy');
                if (Math.random() < 0.7) {
                    if (snoopyInfo && !activeCharacters[snoopyInfo.name]) showCharacter(snoopyInfo);
                } else {
                    const isGuestActive = characters.filter(c => c.type === 'guest').some(c => activeCharacters[c.name]);
                    if (!isGuestActive) {
                        const guestCharacters = characters.filter(c => c.type === 'guest');
                        if (guestCharacters.length > 0) {
                            showCharacter(guestCharacters[Math.floor(Math.random() * guestCharacters.length)]);
                        }
                    }
                }
                setTimeout(characterCycle, 2000 + Math.random() * 2500);
            }

            // --- Start Everything ---
            setupEventListeners();
            setInterval(createDustParticle, 500);
            setInterval(createPetalParticle, 800);
            setTimeout(characterCycle, 10000);
            requestAnimationFrame(animate);
        });
    </script>
</body>